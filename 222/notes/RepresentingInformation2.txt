REVIEW 

BITWISE OPERATIONS

1. 0x5B | 0x45

    01011011
   |01000101
    01011111
    = 0x5F 

2. ~0x5b & 0x45

    ~01011011
    =10100100
    &01000101
     00000100
    = 0x04   

3. ~0x45 | ~(0x4 & 0x8)

    0100        01000101
   &1000       ~10111010
   ~0000   --->|00001111 
    1111 ---   =10111111
               = 0xBF 

LOGICAL OPERATIONS 

1. !0x41 = 0x00

2. 0x55 && 0x6B = 0x01

3. !(0x00 || 0x01) = 0x00

Unsigned/Signed Integers:
- X = x(w-1)x(w-2)...x(1)x(0)

Unsigned: B2U(X) = (sum from i = 0 to w-1)x(i)*2^i
Two's Complement: B2T(X) = -x(w-1)*2^w-1 + (sum from i = 0 to w-2)x(i)*2^i
    - 1 for negative in most significant bit
    - 0 for nonnegative 

char x = 123: 01111011
char y = -123: 10000101

Weight          123         -123
     1           1    1       1     1  
     2           1    2       0     0
     4           0    0       1     4
     8           1    8       0     0
    16           1    16      0     0
    32           1    32      0     0
    64           1    64      0     0
  -128           0    0       1   -128   
                      123         -123  

Numeric Ranges
- Unsigned Values
    - UMin = 0
    - Umax = (2^w)-1
- Two's Complement
    - TMin = -2^w-1
    - Tmax = 2^w-1 -1

Values for w = 16

        Decimal     Hex         Binary
UMax     65535      FF FF     11111111 11111111  
TMax     32767      7F FF     01111111 11111111
TMin    -32768      80 00     10000000 00000000       
-1           -1     FF FF     11111111 11111111  
0             0     00 00     00000000 00000000       


                    Word Sizes
        8       16          32              64
UMax    255    65535    4294967295      ~18 quintillion
TMax    127    32767    2147483647      ~9 quintillion
TMin   -128   -32768   -2147483648      ~-9 quintillion

Observations
|TMin| = TMax + 1
UMax = 2*TMax + 1


C programming:
- #inlude <limits.h>
- Declares the constants:
    - UCHAR_MAX (= 255)
    - CHAR_MAX (=127)
    - CHAR_MIN (=-128)
    - INT_MIN
    - INT_MAX
    - UINT_MAX


Casting Signed to Unsigned in Casting
```
char x = 123;
char y = -123;

unsigned char ux = (unsigned char) x;
unsigned char uy = (unsigned char) y;
```
- C allows conversions between signed and unsigned (as above)
- Resulting Values
    - No change in bit representation
    - Nonnegative values are unchanged 
        - ux = 123
    - Negative values change into positive values
        - uy = 133

- Constants 
    - By default, constants are signed integers

- Casting   
    - Explicit Casting
        int tx, ty
        unsigned ux, uy

        tx = (unsigned) ty
        uy = (unsigned) ty
        tx = (int) uy

    - Implicit casting also occurs via assignments and procedure calls
        tx = ux
        uy = ty

Sign Extension (Two's complement signed values)
- Given a w-bit signed integer x, to convert it to a w+k bit integer of the same value:
- Make k copies of the sign bit
- X = 1001 (-7) w = 4, k = 4 (to reach 8 bits)
- X' = 11111001 (-7) 

2's complement and overflow
- Assume TAdd(u, v) adds u and v together
- Determine if s = TAdd(u, v) overflows

- Overflow if and only if either:
    - u < 0, v < 0, s >= 0 - Negative overflow
    - u >= 0, v >= 0, s < 0 - Positive overflow

Power of 2 Muliplication with shift
- Operation
    - u << k = u * 2^k
    - both signed and unsigned
- Left shift x << y:
    - Shift bit-vector x left y positions 
    - Fill with 0's on right
    - ex: u << 3 = u * 8

Power of 2 division with shift
- Quotient of Unsigned by power of 2
    - u >> k gives u / 2^k
    - uses logical shift
- Quotient of Signed by power of 2
    - u >> k gives u / 2^k
    - uses arithmetic shift
- Right shift: x >> y
    - shift bit-vector x by y positions
    - get rid of extra values on the right
    - Logical Shift: Fill with 0's on left
    - Arithmetic Shift: Fill missing values with sign bit


IEEE 754 Floating Point Representation
- Similar to representation fom 132 course
- Used instead of sign - exponent - mantissa representation
  as there are many ways to represent one number in this format,
  unlike IEEE 754. The normalization preformed disallows this.
- Implicit normalization is also more accurate than a possible 
  explisit normalization.
- Has possible precisions based on number of bits to dictate bias:
    - 16 bits: half-point precision
        - has 11 significand bits (includes sign bit), 
          5 bits for the exponent
        - bias value = 15
    - 32 bits: single-point precision
        - has 24 significand bits (including sign bit),
          8 bits for the exponent
        - bias value = 127
    - 64 bits: double precision
        - has 53 significant bits (including sign bit)
        - bias value = 1023
    - There is a quadruple and Octuple precision, 
      but it will not be discussed further

    - Extra Notes:
        - in the case of the following for exponent = E, mantissa = m, sign = s:
            - E = 0000 0000, M = 00000...000, S = 0 or 1
                - This represents +0 or -0 (same value, 0)
            - E = 1111 1111, M = 00000...000, S = 0
                - This represents positive infinity
            - E = 1111 1111, M = 00000...000, S = 1
                - This represents negative infinity
            - 1 <= E <= 254, M = xxxxx...xxx, S = 0 or 1
                - This is where we use Implicit Normalized Form
                - Conversion completed in class (example later)
            - S = 0 or 1, E = 0, M != 0
                - This represents Fractional form
                - This case has no integer part, so we use a different formula
            - S = 0 or 1, E = 255, M != 0
                - This results in NAN, or Not a number
            
- Decoding Floating point numbers uses the following formula:
    - (-1)^S x 1.M x 2^(E-127)
    - M in this case is the implicit normalized form of the mantissa

- If E = 0 and M != 0, use the following formula for fractional form:
    - (-1)^S x 0.M x 2^(-126)
     
Examples:

- Convert -4.25 to single point precision IEEE 754 floating point number:
Step 1: convert base number (ignoring sign) to binary:
    - 4.25 -> 100.01

Step 2: Use implicit normalization to shift the radix point (decimal point)
        to the right of the most significant bit with a value of 1.
        This shift is done by multiplying your binary value by 2^k
        where k is the number of positions you need to shift your radix
        point.
    - 100.01 -> 1.0001 x 2^2 (we choose 2^2, as we shift our value by 2 positions)
    - the value to the right of the radix point is your new mantissa
        - 0001 in this case. Keep leading 0's 
    - the number your shift by, or put in as k in 2^k is your temporary
      exponent. In this case, this is 2.

Step 3: Bias your exponent by adding 127 to your temporary exponent.
        This will be your "True Exponent". Convert this resulting
        value to binary.
    
    - 2 + 127 = 129
               -128
               -  1
               =  0
    - So our binary representation is 1000 0001

Step 4: Fill in your Sign, exponent, and mantissa together.
        Your sign is based on the original value (-4.25)

    S   Exponent       Mantissa
    1   1000 0001   00010000...000

    Note: fill in the mantissa section from the LEFT side, and follow
          this value by zeros.

Ex 2:
Convert 55 to floating point:
Step 1: 55 -> 110111
Step 2, normalization: 110111 -> 1.10111 x 2^5, note these values
Step 3, bias exponent: 5+127 = 132
Step 3.1 convert to binary: 132 -> 1000 0100
Step 4, fill in values:
    S   Exponent       Mantissa
    0   1000 0100   10111000...000

Ex 3:
Convert the following from IEEE 754 to Decimal
This process is simply to follow the previous steps in the opposite direction

S   Exponent       Mantissa
0   1000 0110   11011000...000

Step 1: Convert E to Decimal, and debias
    1000 0110 = 128 + 4 + 2 = 134
    debias: 134 - 128 = 6 <- this is the amount we shift

Step 2: Build our denormalized form of the value.
        - do this by starting with 1.x...x * 2^k, and fill it in with  
          mantissa and debiased exponent
        - in this case, M = 11011, k = 6
    So we have 1.11011 x 2^6

Step 3: Shift values by moving the decimal right k spaces:
    - 1.11011 x 2^6 -> 1110110

Step 4: Convert value to decimal
    - 1110110 -> 2+4+16+32+64 = 118